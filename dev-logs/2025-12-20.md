# Dev Log: 2025-12-20

## Agenda

- [ ] Refactor multiple aspects of the game
- [ ] Create `game.rs` module to handle aspects of the game such as initial deal, new game, determine winner, etc.
- [ ] Refine modified `Display` trait
- [ ] Start learning and practicing ownership concepts
- [ ] Practice professional documentation techniques for modules, structs, and implications

## Learning

### Memory Concepts

- I will not pretend that I fully understand the memory or ownership concepts which I have reviewed today, as they take much time and practice to comprehend. Take my explanations as someone who is still trying to make sense of computer architecture basics. Here is what I have gotten from today's learning session:
- The stack and the heap, which I have heard about but never looked into as a beginner using Java with a GC, work in completely different ways.
- For the stack, as the name suggests, the order matters. The Book used the example of a stack of plates: last plate on the stack is the first plate off the stack. You cannot grab the middle plate without affecting the plates on top of it. For things to be stored on the stack, the size ***must*** be known.
- For the heap, order does not matter in the same way. There is a chunk of memory allocated for a specific purpose. When you want something, there is a thing called a pointer that finds it for you, and you can modify it without affecting the things around it.

### Basic Ownership Concepts

- Ownership is intimately tied to memory concepts.
- One example the book gave was when you set 2 `Strings` equal to each other. When this is done, another `String` is created in the stack, but the pointer leads you to the same spot in the heap as the first `String`. However, when this is done, the first `String` is deemed invalid, so the computer does not try to free the same memory twice when the vars go out of scope. This effectively means that s1 was moved to s2.
- The book goes on to give examples of functions that either take ownership, make a copy, or take and give back. When you take ownership, the ownership of the var is now passed to that function, and the var's scope is confined within that function that took ownership. When another function makes a copy, there are now 2 identical copies of that var somewhere in memory. This happens with primitive types by default. Finally, when you take and give back, the function called takes ownership, then returns the same var to a var of a different name in the original function. The original var passed to the var of a different name is the same.

### References and Borrowing

- References allow a function to refer to the specific values of an object without actually owning it. It makes it so that you don't have to give ownership to every single method you call. If you are going to call a function and pass an object as an argument just for that function to return that same exact object, using references save you from **1.** the verbocity of moving ownership back and forth and **2.** the need to `.clone()` data, which allocates new, unnecessary heap memory.
- References can be a bit tricky, but the reasoning behind the common compile time errors is logical. While there is a mutable reference within the current scope, you cannot have any other references to that object. However, you can have as many immutable references as you want if there is no mutable reference withing the scope. This is meant to prevent data races (when two or more pointers are accessing the same object at the same time, one is writing, and there is nothing in place to syncronize the changes).
- Dangling references are also a thing, which happens when a reference is returned to deallocated memory that once held an object whose lifetime was confined within the scope of that method that the reference was returned from.

## Achievements

### First Stage of Refactor

- Refactored `all()` methods within `card.rs` module to return references with a static lifetime. 
- When `all()` methods were called by `Deck` in order to loop through enums to populate the deck, instead of passing a vector full of values just for them to get copied again into a `Card` object, I passed a reference to the enums and dereferenced them upon card creation. This saved memory by **1.** not creating a repetitive, temporary vector in the heap and **2.** giving cards ownership of enum values so as to not create excessive pointers.

### New `game.rs` module and `main.rs`

- I copied my old `main.rs` module into a new file that will go unused.
- I emptied `main.rs`, allowing for a fresh start in my next session
- I created a new `game.rs` module to handle the game rules and states

## Struggles

### Error Handling

- Struggled to determine where to handle errors. I eventually decided to handle them on the back end instead of in the `main` function. I was creating the `initial_deal` method in `game.rs`, and figured that I could not deal until it had been determined that a valid bet was placed.
